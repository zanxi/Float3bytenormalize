#include <stdint.h> // определ€ет типы int8_t ... int64_t, uint8_t ... uint64_t


//--------------------------------------------------------------------------------------------------------------------------------- 
// Float-3 передаетс€ в функцию как три старших байта фиктивного числа float-4. ћладший байт при этом может быть любым (игнорируетс€).
//---------------------------------------------------------------------------------------------------------------------------------- 
// ¬ диапазоне значений от 2^(-62) до 2^(+63) мантисса float-3 нормализована, старший бит всегда =1 и скрыт.
// ≈сли число по абсолютной величине меньше 2^(-62), то (по аналогии с IEEE 754) считаетс€, что мантиса ненормализована и скрытый бит =0. 
// ѕризнаком ненормализованности мантиссы €вл€етс€ пор€док =0.
// ѕримечание: в »ћƒ-7, как и в оригинальном формате ATI s16e7, ненормализованна€ мантисса не реализованна.
// ѕор€док равный 0x7F €вл€етс€ признаком бесконечности. Ѕесконечность имеет знак.
//===================================================================================================================================
float f3ati_to_f4ieee (float x)
{
	union 
	{
		float f;
		uint32_t u;
		uint8_t b[4];
	} flt4, flt3;

	int32_t s4, s3;		// «наки float-4 и float-3 
	int32_t e4, e3;		// ѕор€док float-4 и float-3
	int32_t m4, m3;		// ћантисса float-4 и float-3
	int32_t e3_true;	// »стинный пор€док float-3 (с вычтенными смещением 63)

	flt3.f = x;
	flt3.b[0] = 0; // обнул€ем на вс€кий случай младший байт

	s3 = ( flt3.u & 0x80000000 );	// Ѕит знака как есть, без сдвига
	e3 = ( flt3.u >> 24 ) & 0x7F;	// ѕор€док, сдвинутый до упора вправо 
	m3 = ( flt3.u >> 8 ) & 0xFFFF;	// ћантиса без скрытого бита, сдвинута€ до упора вправо
	m3 = e3 ? m3 | 0x10000 : m3 << 1;	// ¬осстановление скрытого старшего бита
  
	s4 = s3;	// знаки в обоих форматах совпадают
	e3_true = e3 - 63;

	if (e3 == 0x7F)	// признак бесконечности infinity (float-3)
	{
		e4 = 0xFF;	// признак бесконечности infinity (float-4)
		m4 = 0;
	}
	else if (m3 == 0)	// число равно нулю (т.к. мантисса с восстановленным скрытым битом равна нулю)
	{
		e4 = 0;
		m4 = 0;	 
	}
	else 
	{	
		e4 = e3_true + 127;
		m4 = m3 << 7;
		if (e3 == 0)	// мантисса float-3 денормализована (и не равна нулю, т.к. уже проверили)
		{
			while (!(m4 & 0x800000))	// нормализаци€ мантиссы с одновременной коррекцией пор€дка
			{
				e4--;
				m4 = m4 << 1;
			}
		}
	}
  
	e4 = e4 << 23;	// сдвиг пор€дка в старший байт (из 4х)
	m4 = (m4 & 0x7FFFFF);	// ### 08.12.2016 (было 0x3FFFFF)
	flt4.u = s4 | e4 | m4;

	return flt4.f;
}




